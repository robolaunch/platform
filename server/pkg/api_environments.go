/*
 * robolaunch Industry Cloud Platform - OpenAPI 3.0
 *
 * API for robolaunch ICP platform structure.
 *
 * API version: 1.0.11
 * Contact: info@robolaunch.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"net/http"
	"net/url"
	"reflect"

	"github.com/gorilla/mux"
	"github.com/robolaunch/platform/server/pkg/models"
)

// *****Environment*****
func GetEnvironment(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(structToJSONByteArray(GetEnvironmentResponse(mux.Vars(r), r.URL.Query())))
}

func GetEnvironmentResponse(pathParams map[string]string, queryParams url.Values) models.ResponseEnvironment {

	var version string

	base := queryParams.Get("base")
	application := queryParams.Get("application")
	appVersion := queryParams.Get("appVersion")
	ubuntu := queryParams.Get("ubuntu")
	desktop := queryParams.Get("desktop")

	domainResponse := GetEnvironmentsOfDomainResponse(pathParams, queryParams)

	if val, ok := pathParams["version"]; ok {
		version = val
	} else {
		return models.ResponseEnvironment{
			Success: false,
			Message: "Version is not identified in path.",
		}
	}

	if !domainResponse.Success {
		return models.ResponseEnvironment{
			Success: false,
			Message: domainResponse.Message,
		}
	}

	selectedEnv := models.Environment{}

	for _, environment := range domainResponse.Response.Environments {
		if environment.Base.Version == base &&
			environment.Base.Ubuntu == ubuntu &&
			environment.Base.Desktop == desktop &&
			environment.Application.Name == application &&
			environment.Application.Version == appVersion {
			selectedEnv = environment
		}
	}

	if !reflect.DeepEqual(selectedEnv, models.Environment{}) {
		return models.ResponseEnvironment{
			Success:  true,
			Message:  "Environment '" + application + "' is returned for version '" + version + "' of the robolaunch ICP in a specific domain",
			Response: &selectedEnv,
		}
	} else {
		return models.ResponseEnvironment{
			Success: false,
			Message: "Environment '" + application + "' is not found for version '" + version + "' with the parameters given.",
		}
	}

}

// *****Domain*****
func GetEnvironmentsOfDomain(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(structToJSONByteArray(GetEnvironmentsOfDomainResponse(mux.Vars(r), r.URL.Query())))
}

func GetEnvironmentsOfDomainResponse(pathParams map[string]string, queryParams url.Values) models.ResponseDomain {

	var version string
	var domain string

	if val, ok := pathParams["version"]; ok {
		version = val
	} else {
		return models.ResponseDomain{
			Success: false,
			Message: "Version is not identified in path.",
		}
	}

	if val, ok := pathParams["domain"]; ok {
		domain = val
	} else {
		return models.ResponseDomain{
			Success: false,
			Message: "Domain is not identified in path.",
		}
	}

	versionedPlatformImagesResponse := GetVersionedPlatformImagesResponse(pathParams, queryParams)

	if !versionedPlatformImagesResponse.Success {
		return models.ResponseDomain{
			Success: false,
			Message: versionedPlatformImagesResponse.Message,
		}
	}

	if domainObj, domainExists := versionedPlatformImagesResponse.Response.Domains[domain]; domainExists {
		return models.ResponseDomain{
			Success:  true,
			Message:  "Environments are listed for domain '" + domain + "' in version '" + version + "' of the robolaunch ICP",
			Response: &domainObj,
		}
	} else {
		return models.ResponseDomain{
			Success: false,
			Message: "Selected domain '" + domain + "' is not found in platform version " + version + ".",
		}
	}

}

// *****PlatformImages*****
func GetPlatformImages(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(structToJSONByteArray(GetPlatformImagesResponse(r.URL.Query())))
}

func GetPlatformImagesResponse(queryParams url.Values) models.ResponsePlatformImages {

	url := queryParams.Get("url")

	platformImages, err := GetStructuredPlatformImages(url)
	if err != nil {
		return models.ResponsePlatformImages{
			Success: false,
			Message: err.Error(),
		}
	}

	return models.ResponsePlatformImages{
		Success:  true,
		Message:  "Domains and environment are listed of every active/available version of the robolaunch ICP.",
		Response: &platformImages,
	}

}

// *****VersionedPlatformImages*****
func GetVersionedPlatformImages(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(structToJSONByteArray(GetVersionedPlatformImagesResponse(mux.Vars(r), r.URL.Query())))
}

func GetVersionedPlatformImagesResponse(pathParams map[string]string, queryParams url.Values) models.ResponseVersionedPlatformImages {

	var version string

	if val, ok := pathParams["version"]; ok {
		version = val
	} else {
		return models.ResponseVersionedPlatformImages{
			Success: false,
			Message: "Version is not identified in path.",
		}
	}

	platformImagesResponse := GetPlatformImagesResponse(queryParams)
	if !platformImagesResponse.Success {
		return models.ResponseVersionedPlatformImages{
			Success: false,
			Message: platformImagesResponse.Message,
		}
	}

	if vpi, vpiExists := platformImagesResponse.Response.Versions[version]; vpiExists {
		return models.ResponseVersionedPlatformImages{
			Success:  true,
			Message:  "Domains and environment are listed of version '" + version + "' of the robolaunch ICP.",
			Response: &vpi,
		}
	} else {
		return models.ResponseVersionedPlatformImages{
			Success: true,
			Message: "Selected platform version '" + version + "' is not found.",
		}
	}

}
